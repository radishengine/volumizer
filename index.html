<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <title>Volumizer</title>
    <script src='VolumizerClient.js'></script>
    <style>
      body {
        font-family: sans-serif;
        font-size: small;
      }
      #dropzone {
        display: none;
        position: fixed;
        z-order: 1000;
        background: rgba(255, 255, 255, 0.);
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        padding: 30px;
      }
      .drop-border {
        border: 10px dashed silver;
        height: 100%;
      }
      body.dropping > #dropzone {
        display: block;
      }
      .container > .children {
        padding-left: 0.75em;
      }
      .container > .title {
        white-space: pre-wrap;
        cursor: default;
        letter-spacing -0.05em;
      }
      .container.hidden > .title {
        opacity: 0.6;
      }
      .container:not(.open) > .children {
        display: none;
      }
      .toggler {
        width: 1em;
        background: none;
        border: none;
        outline: none;
        padding: 0;
        margin: 0;
        text-align: right;
      }
      .container:not(.open) > .toggler::before {
        content: '\25b6';
      }
      .container.open > .toggler::before {
        content: '\25BC';
      }
      .container.empty > .toggler {
        visibility: hidden;
      }
      .container > .symbol {
        width: 1.2em;
        display: inline-block;
        text-align: right;
      }
      .container[data-sectors] > .symbol::before {
        content: '\1F4BE';
        cursor: pointer;
      }
      .container[data-kind] > .symbol::before {
        content: '\1F4E6';
      }
      .container > .symbol::before {
        content: '\1F4C4';
      }
      .container.folder > .symbol::before {
        content: '\1F4C2';
      }
      .container.open.loading > .toggler::before {
        content: '\231B';
      }
      .container.open.loading > .toggler {
        cursor: progress;
      }
      .symbol.loading {
        cursor: progress;
      }
      .symbol.loading::before {
        content: '\231B';
      }
      .symbol.error::before {
        content: '\26A0';
      }
    </style>
  </head>
  <body>
    <div id='dropzone'>
      <div class='drop-border'></div>
    </div>
    <div id='templates' style='display:none'>
      <div class='container'>
        <button class='toggler'></button><span class='symbol'></span>
        <span class='title'></span>
        <div class='children'>
        </div>
      </div>
    </div>
    <div id='content'>
    </div>
    <script>
      
      var blobVC = new VolumizerClient;
      
      document.getElementById('content').addEventListener('click', function(e) {
        for (var el = e.target; el !== this; el = el.parentNode) {
          if (el.classList.contains('container')) {
            if (el.classList.contains('empty')) {
              break;
            }
            var nowOpen = el.classList.toggle('open');
            if (nowOpen
                && 'kind' in el.dataset
                && !el.classList.contains('loading')
                && !el.classList.contains('source')) {
              el.classList.add('loading');
            }
            break;
          }
          if (el.classList.contains('symbol')) {
            var symbolEl = el;
            if (symbolEl.classList.contains('loading')) {
              return;
            }
            for (var containerEl = symbolEl.parentNode; containerEl !== this; containerEl = containerEl.parentNode) {
              if (!containerEl.classList.contains('container')) continue;
              if (!('sectors' in containerEl.dataset)) break;
              var sectors = containerEl.dataset.sectors.split(';').map(function(sector) {
                sector = sector.split(',');
                return {offset:+sector[0], length:+sector[1]};
              });
              for (var sourceEl = containerEl; sourceEl !== this.parentNode; sourceEl = sourceEl.parentNode) {
                if (!(sourceEl.classList.contains('source'))) continue;
                symbolEl.classList.add('loading');
                blobVC.task({
                  headline: 'get-blob',
                  source: sourceEl.source,
                  sectors: sectors,
                })
                .then(function(blob) {
                  symbolEl.classList.remove('loading');
                  var a = document.createElement('A');
                  a.setAttribute('href', URL.createObjectURL(blob));
                  a.setAttribute('download', containerEl.dataset.filename);
                  document.body.appendChild(a);
                  a.click();
                  document.body.removeChild(a);
                })
                .catch(function(reason) {
                  symbolEl.classList.remove('loading');
                  symbolEl.classList.add('error');
                  symbolEl.setAttribute('title', reason || 'error');
                });
                return;
              }
              break;
            }
          }
        }
      });
      
      var vc = null;
      
      function getElementForPath(path) {
        var id = path.map(encodeURIComponent).join('/');
        var el = document.getElementById(id);
        if (!el) {
          var el = document.querySelector('#templates > .container').cloneNode(true);
          el.setAttribute('id', id);
          el.titleElement = el.querySelector('.title');
          el.titleElement.innerText = path[path.length-1];
          el.childrenElement = el.querySelector('.children');
          el.classList.add('empty');
          if (path.length === 1) {
            var root = document.getElementById('content');
            root.appendChild(el);
            el.classList.add('open');
            if (root.classList.contains('loading')) {
              el.classList.add('loading');
            }
          }
          else {
            var parentEl = getElementForPath(path.slice(0, -1));
            parentEl.classList.remove('empty');
            parentEl.childrenElement.appendChild(el);
          }
        }
        return el;
      }
      
      function loadFile(file, structure, sectors) {
        var vc = blobVC;
        document.body.classList.remove('cancelled', 'error');
        document.body.classList.add('loading');
        var root = document.getElementById('content');
        root.classList.add('source', 'loading');
        root.innerHTML = '';
        root.source = file;
        vc.task(
          {
            headline: 'volumize',
            source: file,
            sectors: sectors,
            structure: structure,
          },
          {
            onentry: function(entry) {
              if ('path' in entry) {
                var el = getElementForPath(entry.path);
                if (entry.metadata.isInvisible) {
                  el.classList.add('hidden');
                }
                if (entry.metadata.isFolder) {
                  el.classList.add('folder');
                }
                else {
                  el.classList.add('file');
                }
                var filename = entry.path.slice(-1)[0];
                if (entry.sectors && entry.sectors.length > 0) {
                  el.dataset.filename = filename;
                  el.dataset.sectors = entry.sectors.map(function(sector) {
                    return sector.offset + ',' + sector.length;
                  }).join(';');
                  if (entry.metadata.type === 'STAK') {
                    var stackEl = getElementForPath(entry.path.concat('[stack]'));
                    stackEl.dataset.filename = filename + '.stak';
                    stackEl.dataset.kind = 'hypercard/stack';
                    stackEl.classList.add('hidden');
                    stackEl.classList.remove('empty');
                    stackEl.dataset.sectors = el.dataset.sectors;
                  }
                }
                if (entry.secondary
                    && entry.secondary.resourceFork
                    && entry.secondary.resourceFork.sectors
                    && entry.secondary.resourceFork.sectors.length > 0) {
                  el = getElementForPath(entry.path.concat('[resources]'));
                  el.dataset.filename = filename + '.rsrc';
                  el.dataset.kind = 'mac/resource-fork';
                  el.classList.add('hidden');
                  el.classList.remove('empty');
                  el.dataset.sectors = entry.secondary.resourceFork.sectors.map(function(sector) {
                    return sector.offset + ',' + sector.length;
                  }).join(';');
                }
              }
              else if (entry.as === 'mac/partitioned') {
                var type = entry.metadata.type.toLowerCase();
                if (type === 'apple_hfs') {
                  loadFile(file, ['mac/hfs'], entry.sectors);
                }
                else if (type === 'apple_mfs') {
                  loadFile(file, ['mac/mfs'], entry.sectors);
                }
              }
              else {
                console.dir(entry);
              }
            },
          }
        ).then(function() {
          for (var el = root.firstElementChild; el; el = el.nextElementSibling) {
            el.classList.remove('loading');
          }
        })
        .catch(function(reason) {
          for (var el = root.firstElementChild; el; el = el.nextElementSibling) {
            el.classList.remove('loading');
            el.classList.add('error');
          }
        });
      }
      
      function onFile(file, sectors) {
        var structure = [];
        if (/\.(?:iso|dsk|img|image|toast|cdr)$/i.test(file.name)) {
          structure.push('mac/partitioned', 'mac/hfs', 'mac/mfs');
        }
        if (/\.rsrc$/i.test(file.name)) {
          structure.push('mac/single-or-double');
        }
        if (/\.sit$/i.test(file.name)) {
          structure.push('sit/v5', 'sit/original');
        }
        if (structure.length === 0) {
          alert('unrecognized file type');
          return;
        }
        return loadFile(file, structure, [{offset:0, length:file.size}]);
      }
      
      document.body.dragEnterCount = 0;
      
      document.body.ondragenter = function(e) {
        e.preventDefault();
        if (++document.body.dragEnterCount === 1) {
          e.dataTransfer.dropEffect = 'copy';
          document.body.classList.add('dropping');
        }
      };

      document.documentElement.ondragenter = function(e) {
        e.preventDefault();
        document.body.classList.add('dropping');
      };
      document.body.ondragleave = function(e) {
        e.preventDefault();
        if (--document.body.dragEnterCount === 0) {
          document.body.classList.remove('dropping');
        }
      };
      document.body.ondragover = function(e) {
        e.preventDefault();
      }
      document.body.ondragend = function(e) {
        e.preventDefault();
        document.body.classList.remove('dropping');
      };
      document.body.ondrop = function(e) {
        e.preventDefault();
        document.body.classList.remove('dropping');
        var file = e.dataTransfer.files && e.dataTransfer.files[0];
        if (file) {
          if (/^#?(upload:|$)/.test(location.hash)) {
            history.replaceState(undefined, undefined, '#upload:' + file.name);
          }
          else {
            history.pushState(undefined, undefined, '#upload:' + file.name);
          }
          onFile(file);
        }
      };
      
      window.onkeydown = function(e) {
        if (e.keyCode === 27) {
          if (vc) {
            vc.close();
            vc = null;
            document.body.classList.add('cancelled');
          }
        }
      };
      
    </script>
  </body>
</html>
