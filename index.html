<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <title>Volumizer</title>
    <script src='volumizer.js'></script>
    <!--
    <script src='VolumizerClient.js'></script>
    -->
    <style>
      #loadbar {
        background: green;
        position: fixed;
        pointer-events: none;
        opacity: 0.75;
        left: 0;
        right: 0;
        top: 0;
        height: 3px;
        transform-origin: left;
        transition: transform 0.1s, opacity 0.3s;
      }
      #dropzone {
        display: none;
        position: fixed;
        z-order: 1000;
        background: rgba(255, 255, 255, 0.);
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        padding: 30px;
      }
      .drop-border {
        border: 10px dashed silver;
        height: 100%;
      }
      body.dropping > #dropzone {
        display: block;
      }
      
      #frame {
        position: fixed;
        display: flex;
        flex-flow: row nowrap;
        overflow: hidden;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
      }
      #content {
        flex-grow: 1;
        overflow-x: none;
        overflow-y: auto;
        overflow-y: scroll;
        padding: 4px;
      }
      #viewer {
        background: black;
        color: white;
      }
      
      .item-self {
        display: flex;
        flex-flow: row nowrap;
        align-items: center;
      }
      .item-self:hover {
        background: rgba(128,128,128,0.2);
      }
      .item.selected > .item-self {
        background: #ccf;
      }
      .item.selected > .item-self:hover {
        background: #bbe;
      }
      .item-self > .toggler {
        background: none;
        border: none;
        outline: none;
        padding: 0;
        margin: 0;
        width: 1em;
        text-align: right;
        cursor: pointer;
      }
      .item:not(.open) > .item-self > .toggler::before {
        content: '\25b6';
      }
      .item-children {
        padding-left: 0.75em;
      }
      .item:not(.open) > .item-children {
        display: none;
      }
      .item.open > .item-self > .toggler::before {
        content: '\25bc';
      }
      .item.open.fetching > .item-self > .toggler::before {
        content: '\231B';
      }
      .item.empty > .item-self > .toggler {
        visibility: hidden;
      }
      .item-self > .symbol {
      }
      .item-self > .symbol::before {
        content: '\1F4C4';
      }
      .item-self.folder > .symbol::before {
        content: '\1F4C2';
      }
      .item-self > .item-title {
        cursor: default;
        font: small-caption;
        text-overflow: ellipsis;
        white-space: nowrap;
        overflow: hidden;
        flex-grow: 1;
      }
      .item-self > time {
        font-family: monospace;
        font-size: smaller;
        opacity: 0.5;
      }
      /*
      .container > .children {
        padding-left: 0.75em;
      }
      .container > .title {
        white-space: pre-wrap;
        cursor: default;
        letter-spacing -0.05em;
      }
      .container.hidden > .title {
        opacity: 0.6;
      }
      .container:not(.open) > .children {
        display: none;
      }
      .toggler {
        width: 1em;
        background: none;
        border: none;
        outline: none;
        padding: 0;
        margin: 0;
        text-align: right;
      }
      .container:not(.open) > .toggler::before {
        content: '\25b6';
      }
      .container.open > .toggler::before {
        content: '\25BC';
      }
      .container.empty > .toggler {
        visibility: hidden;
      }
      .container > .symbol {
        width: 1.2em;
        display: inline-block;
        text-align: right;
      }
      .container[data-sectors] > .symbol::before {
        content: '\1F4BE';
        cursor: pointer;
      }
      .container[data-kind] > .symbol::before {
        content: '\1F4E6';
      }
      .container > .symbol::before {
        content: '\1F4C4';
      }
      .container.folder > .symbol::before {
        content: '\1F4C2';
      }
      .container.open.loading > .toggler::before, .symbol.loading::before {
        content: '\231B';
      }
      .container.open.error > .toggler::before, .symbol.error::before {
        content: '\26D4';
      }
      .container.open.loading > .toggler {
        cursor: progress;
      }
      .symbol.loading {
        cursor: progress;
      }
      */
    </style>
  </head>
  <body>
    <div id='loadbar' style='transform:scaleX(0); opacity:0;'></div>
    <div id='dropzone'>
      <div class='drop-border'></div>
    </div>
    <div id='templates' style='display:none'>
      <div class='item'>
        <div class='item-self' tabindex='-1'>
          <button class='toggler'></button>
          <span class='symbol'></span>
          <span class='item-title'></span>
          <time></time>
        </div>
        <div class='item-children'>
        </div>
      </div>
    </div>
    <div id='frame'>
      <div id='content' data-selection-mode='range'>
      </div>
      <div id='viewer'>
      </div>
    </div>
    <!--
    <script>
      
      var vc = null;
      var blobVC = new VolumizerClient;
      
      function initItem(item) {
        var filename = item.dataset.filename || '';
        var structure = [];
        var encoding = null;
        if (/\.(?:iso|dsk|img|image|toast|cdr)$/i.test(filename)) {
          structure.push('mac/partitioned', 'mac/hfs', 'mac/mfs');
        }
        if (/\.rsrc$/i.test(filename)) {
          structure.push('mac/single-or-double');
        }
        if (/\.stak$/i.test(filename)) {
          structure.push('hypercard/stack');
        }
        if (/\.sit$/i.test(filename)) {
          structure.push('sit/v5', 'sit/original');
        }
        if (/\.sea$/i.test(filename)) {
          structure.push('sit/original');
        }
        if (/\.hqx$/i.test(filename)) {
          structure.push('mac/hqx');
          encoding = 'mac/hqx';
        }
        if (structure.length) item.dataset.kind = structure.join(' ');
        if (encoding) item.dataset.encoding = encoding;
      }
      
      function createItemElement() {
        var el = document.querySelector('#templates > .container').cloneNode(true);
        el.titleElement = el.querySelector('.title');
        el.childrenElement = el.querySelector('.children');
        el.symbolElement = el.querySelector('.symbol');
        el.classList.add('empty');
        return el;
      }
      
      function getElementForPath(pathRoot, path) {
        if (path.length === 0) return pathRoot;
        var encoded = path.map(encodeURIComponent).join('/');
        var els = pathRoot.querySelectorAll('[data-path="' + encoded.replace('/', '\\/') + '"]');
        var el;
        finding: for (var i = 0; i < els.length; i++) {
          for (var ancestor = els[i].parentNode; ancestor !== pathRoot; ancestor = ancestor.parentNode) {
            if (ancestor.classList.contains('path-root')) continue finding;
          }
          el = els[i];
          break;
        }
        if (!el) {
          el = createItemElement();
          el.dataset.path = encoded;
          el.dataset.filename = el.titleElement.innerText = path[path.length-1];
          if (path.length === 1) {
            pathRoot.childrenElement.appendChild(el);
          }
          else {
            var parentEl = getElementForPath(pathRoot, path.slice(0, -1));
            parentEl.classList.remove('empty');
            parentEl.childrenElement.appendChild(el);
          }
        }
        return el;
      }
      
      function encodeSectors(sectors) {
        return sectors.map(function(sector) {
          return sector.offset + ',' + sector.length;
        }).join(';');
      }
      
      function decodeSectors(sectorString) {
        return sectorString.split(';').map(function(sector) {
          sector = sector.split(',');
          return {offset:+sector[0], length:+sector[1]};
        });
      }
      
      function decodeEl(encodedEl, sourceEl) {
        return blobVC.task({
          headline: 'decode',
          encoding: encodedEl.dataset.encoding,
          decodedLength: +encodedEl.dataset.decodedLength,
          source: sourceEl.source,
          sectors: decodeSectors(encodedEl.dataset.sectors),
        })
        .then(function(result) {
          encodedEl.source = result;
          delete encodedEl.dataset.encoding;
          delete encodedEl.dataset.decodedLength;
          encodedEl.dataset.sectors = '0,' + result.size;
          encodedEl.classList.add('source');
        });
      }
      
      function downloadEl(el, sourceEl) {
        return blobVC.task({
          headline: 'get-blob',
          source: sourceEl.source,
          sectors: decodeSectors(el.dataset.sectors),
        })
        .then(function(blob) {
          var a = document.createElement('A');
          a.setAttribute('href', URL.createObjectURL(blob));
          a.setAttribute('download', el.dataset.filename);
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
        });
      }
      
      function volumizeEl(volumeEl, sourceEl) {
        return blobVC.task({
          headline: 'volumize',
          sectors: decodeSectors(volumeEl.dataset.sectors),
          source: sourceEl.source,
          structure: volumeEl.dataset.kind.split(' '),
        },
        {
          onentry: function(entry) {
            var item = getElementForPath(volumeEl, entry.path);
            item.classList.remove('empty');
            if (entry.metadata.isFolder) item.classList.add('folder');
            if (entry.metadata.isInvisible) item.classList.add('hidden');
            if (entry.sectors && entry.sectors.length > 0) {
              item.dataset.sectors = encodeSectors(entry.sectors);
              if ('encoding' in entry) {
                item.dataset.encoding = entry.encoding;
                item.dataset.decodedLength = entry.decodedLength;
              }
            }
            if (entry.secondary
                && entry.secondary.resourceFork
                && entry.secondary.resourceFork.sectors
                && entry.secondary.resourceFork.sectors.length > 0) {
              var resItem = createItemElement();
              resItem.titleElement.innerText = '[resources]';
              resItem.dataset.kind = 'mac/resource-fork';
              resItem.dataset.sectors = encodeSectors(entry.secondary.resourceFork.sectors);
              if ('encoding' in entry.secondary.resourceFork) {
                resItem.dataset.encoding = entry.secondary.resourceFork.encoding;
                resItem.dataset.decodedLength = entry.secondary.resourceFork.decodedLength;
              }
              resItem.classList.remove('empty');
              resItem.classList.add('hidden');
              item.childrenElement.appendChild(resItem);
            }
            initItem(item);
            /*
            var path = ('path' in entry) ? entry.path : [entry.metadata.type];
            var folder = getElementForPath(volumeEl, path);
            if (entry.metadata.isFolder || !('path' in entry)) folder.classList.add('folder');
            folder.classList.remove('empty');
            var entryEl = createItemElement();
            entryEl.titleElement.innerText = '[' + entry.metadata.id + ']';
            if (entry.metadata.name) {
              entryEl.titleElement.innerText += ' ' + entry.metadata.name;
            }
            if (entry.sectors && entry.sectors.length > 0) {
              entryEl.dataset.sectors = encodeSectors(entry.sectors);
            }
            folder.childrenElement.appendChild(entryEl);
            */
          },
        });
      }
      
      document.getElementById('content').addEventListener('click', function(e) {
        for (var el = e.target; el !== this; el = el.parentNode) {
          if (el.classList.contains('container')) {
            if (el.classList.contains('empty')) {
              break;
            }
            var nowOpen = el.classList.toggle('open');
            if (nowOpen
                && 'kind' in el.dataset
                && !el.classList.contains('loading')
                && !el.classList.contains('loaded')) {
              for (var sourceEl = el; sourceEl; sourceEl = sourceEl.parentNode) {
                if (!sourceEl.classList.contains('source')) continue;
                el.classList.add('loading');
                var promise;
                if ('encoding' in el.dataset) {
                  promise = decodeEl(el, sourceEl)
                  .then(volumizeEl.bind(null, el, el));
                }
                else {
                  promise = volumizeEl(el, sourceEl);
                }
                promise.then(function() {
                  el.classList.remove('loading');
                  el.classList.add('loaded');
                  if (!el.childrenElement.firstElementChild) {
                    el.classList.add('empty');
                  }
                })
                .catch(function() {
                  el.classList.remove('loading');
                  el.classList.add('loaded');
                  el.classList.add('error');
                });
                break;
              }
            }
            break;
          }
          if (el.classList.contains('symbol')) {
            var symbolEl = el;
            if (symbolEl.classList.contains('loading')) {
              return;
            }
            for (var containerEl = symbolEl.parentNode; containerEl !== this; containerEl = containerEl.parentNode) {
              if (!containerEl.classList.contains('container')) continue;
              if (!('sectors' in containerEl.dataset)) break;
              var sectors = containerEl.dataset.sectors.split(';').map(function(sector) {
                sector = sector.split(',');
                return {offset:+sector[0], length:+sector[1]};
              });
              for (var sourceEl = containerEl; sourceEl !== this.parentNode; sourceEl = sourceEl.parentNode) {
                if (!(sourceEl.classList.contains('source'))) continue;
                symbolEl.classList.add('loading');
                var promise;
                if ('encoding' in containerEl.dataset) {
                  promise = decodeEl(containerEl, sourceEl)
                  .then(downloadEl.bind(null, containerEl, containerEl));
                }
                else {
                  promise = downloadEl(containerEl, sourceEl);
                }
                promise.then(function() {
                  symbolEl.classList.remove('loading');
                })
                .catch(function(reason) {
                  symbolEl.classList.remove('loading');
                  symbolEl.classList.add('error');
                  symbolEl.setAttribute('title', reason || 'error');
                });
                return;
              }
              break;
            }
          }
        }
      });
      
      function loadFile(file, sectors) {
        var item = createItemElement();
        item.source = file;
        item.titleElement.innerText = file.name;
        item.dataset.filename = file.name;
        item.classList.add('source', 'path-root');
        item.classList.remove('empty');
        item.dataset.sectors = encodeSectors(sectors);
        initItem(item);
        document.getElementById('content').appendChild(item);
        /*
        if (encoding) item.dataset.encoding = encoding;
        root.childrenElement = root;
        root.classList.add('source', 'loading', 'path-root');
        root.innerHTML = '';
        root.source = file;
        vc.task(
          {
            headline: 'volumize',
            source: file,
            sectors: sectors,
            structure: structure,
          },
          {
            onentry: function(entry) {
              if ('path' in entry) {
                var el = getElementForPath(root, entry.path);
                if (entry.path.length === 1) {
                  el.classList.add('loading', 'open');
                }
                if (entry.metadata.isInvisible) {
                  el.classList.add('hidden');
                }
                if (entry.metadata.isFolder) {
                  el.classList.add('folder');
                }
                else {
                  el.classList.add('file');
                }
                if ('encoding' in entry) {
                  el.dataset.encoding = entry.encoding;
                  if ('decodedLength' in entry) {
                    el.dataset.decodedLength = ''+entry.decodedLength;
                  }
                }
                var filename = entry.path.slice(-1)[0];
                if (entry.sectors && entry.sectors.length > 0) {
                  el.dataset.filename = filename;
                  el.dataset.sectors = entry.sectors.map(function(sector) {
                    return sector.offset + ',' + sector.length;
                  }).join(';');
                  if (entry.metadata.type === 'STAK') {
                    var stackEl = getElementForPath(root, entry.path.concat('[stack]'));
                    stackEl.dataset.filename = filename + '.stak';
                    stackEl.dataset.kind = 'hypercard/stack';
                    stackEl.classList.add('hidden', 'path-root');
                    stackEl.classList.remove('empty');
                    stackEl.dataset.sectors = el.dataset.sectors;
                  }
                }
                if (entry.secondary
                    && entry.secondary.resourceFork
                    && entry.secondary.resourceFork.sectors
                    && entry.secondary.resourceFork.sectors.length > 0) {
                  el = getElementForPath(root, entry.path.concat('[resources]'));
                  el.dataset.filename = filename + '.rsrc';
                  el.dataset.kind = 'mac/resource-fork';
                  el.classList.add('hidden', 'path-root');
                  el.classList.remove('empty');
                  el.dataset.sectors = entry.secondary.resourceFork.sectors.map(function(sector) {
                    return sector.offset + ',' + sector.length;
                  }).join(';');
                  if ('encoding' in entry.secondary.resourceFork) {
                    el.dataset.encoding = entry.secondary.resourceFork.encoding;
                    if ('decodedLength' in entry.secondary.resourceFork) {
                      el.dataset.decodedLength = ''+entry.secondary.resourceFork.decodedLength;
                    }
                  }                  
                }
              }
              else if (entry.as === 'mac/partitioned') {
                var type = entry.metadata.type.toLowerCase();
                if (type === 'apple_hfs') {
                  loadFile(file, ['mac/hfs'], null, entry.sectors);
                }
                else if (type === 'apple_mfs') {
                  loadFile(file, ['mac/mfs'], null, entry.sectors);
                }
              }
              else {
                console.dir(entry);
              }
            },
          }
        ).then(function() {
          for (var el = root.firstElementChild; el; el = el.nextElementSibling) {
            el.classList.remove('loading');
          }
        })
        .catch(function(reason) {
          for (var el = root.firstElementChild; el; el = el.nextElementSibling) {
            el.classList.remove('loading');
            el.classList.add('error');
          }
        });
        */
      }
      
      function onFile(file, sectors) {
        return loadFile(file, [{offset:0, length:file.size}]);
      }
      
      document.body.dragEnterCount = 0;
      
      document.body.ondragenter = function(e) {
        e.preventDefault();
        if (++document.body.dragEnterCount === 1) {
          e.dataTransfer.dropEffect = 'copy';
          document.body.classList.add('dropping');
        }
      };

      document.documentElement.ondragenter = function(e) {
        e.preventDefault();
        document.body.classList.add('dropping');
      };
      document.body.ondragleave = function(e) {
        e.preventDefault();
        if (--document.body.dragEnterCount === 0) {
          document.body.classList.remove('dropping');
        }
      };
      document.body.ondragover = function(e) {
        e.preventDefault();
      }
      document.body.ondragend = function(e) {
        e.preventDefault();
        document.body.classList.remove('dropping');
      };
      document.body.ondrop = function(e) {
        e.preventDefault();
        document.body.classList.remove('dropping');
        var file = e.dataTransfer.files && e.dataTransfer.files[0];
        if (file) {
          if (/^#?(upload:|$)/.test(location.hash)) {
            history.replaceState(undefined, undefined, '#upload:' + file.name);
          }
          else {
            history.pushState(undefined, undefined, '#upload:' + file.name);
          }
          onFile(file);
        }
      };
      
      window.onkeydown = function(e) {
        if (e.keyCode === 27) {
          if (vc) {
            vc.close();
            vc = null;
          }
        }
      };
      
    </script>
    -->
    <script>
      
      document.body.dragEnterCount = 0;
      
      document.body.ondragenter = function(e) {
        e.preventDefault();
        if (++document.body.dragEnterCount === 1) {
          e.dataTransfer.dropEffect = 'copy';
          document.body.classList.add('dropping');
        }
      };

      document.documentElement.ondragenter = function(e) {
        e.preventDefault();
        document.body.classList.add('dropping');
      };
      document.body.ondragleave = function(e) {
        e.preventDefault();
        if (--document.body.dragEnterCount === 0) {
          document.body.classList.remove('dropping');
        }
      };
      document.body.ondragover = function(e) {
        e.preventDefault();
      }
      document.body.ondragend = function(e) {
        e.preventDefault();
        document.body.classList.remove('dropping');
      };
      document.body.ondrop = function(e) {
        e.preventDefault();
        document.body.classList.remove('dropping');
        volumizer.loadFromDataTransfer(e.dataTransfer);
      };
      
      function updateItemElement(el, item) {
        el.titleElement.innerText = item.name;
        el.selfElement.className = ['item-self'].concat(item.classList || []).join(' ');
        el.classList.toggle('empty', item.childCount === 0);
        return el;
      }
      
      function makeItemElement(item) {
        var template = document.querySelector('#templates > .item').cloneNode(true);
        template.setAttribute('id', 'item-' + item.id);
        if ('source' in item) {
          template.dataset.source = item.source;
        }
        if ('sectors' in item) {
          template.dataset.sectors = item.sectors;
        }
        template.selfElement = template.querySelector('.item-self');
        template.titleElement = template.selfElement.querySelector('.item-title');
        template.childrenElement = template.querySelector('.item-children');
        return updateItemElement(template, item);
      }
      
      var itemTree = document.getElementById('content');
      
      itemTree.addEventListener('mousedown', function onmousedown(e) {
        for (var target = e.target; target !== this; target = target.parentNode) {
          if (target.classList.contains('item-self')) {
            target = target.parentNode;
            break;
          }
        }
        if (target === this) return;
        e.preventDefault();
        if (e.target.classList.contains('toggler')) return;
      });
      
      itemTree.addEventListener('click', function onclick(e) {
        for (var target = e.target; target !== this; target = target.parentNode) {
          if (target.classList.contains('item-self')) {
            target = target.parentNode;
            break;
          }
        }
        if (target === this) return;
        e.preventDefault();
        if (e.target.classList.contains('toggler')) {
          target.dispatchEvent(new Event('item-toggle', {bubbles:true}));
          return;
        }
        if (e.shiftKey) {
          target.dispatchEvent(new Event('item-range', {bubbles:true}));
        }
        else if (e.ctrlKey) {
          target.dispatchEvent(new Event('item-set', {bubbles:true}));
        }
        else {
          this.selectItemRange(target, target);
        }
        this.focusItem = target;
      }, true);
      
      itemTree.addEventListener('dblclick', function ondblclick(e) {
        for (var target = e.target; target !== this; target = target.parentNode) {
          if (target.classList.contains('item-self')) {
            target = target.parentNode;
            break;
          }
        }
        if (target === this) return;
        e.preventDefault();
        target.dispatchEvent(new Event('item-toggle', {bubbles:true}));
      }, true);
      
      itemTree.addEventListener('item-toggle', function onitemtoggle(e) {
        if (e.target.classList.contains('open')) {
          e.target.dispatchEvent(new Event('item-close', {bubbles:true}));
        }
        else {
          e.target.dispatchEvent(new Event('item-open', {bubbles:true}));
        }
      });
      
      itemTree.addEventListener('item-close', function onitemclose(e) {
        var itemEl = e.target;
        itemEl.classList.remove('open');
        var selected = itemEl.childrenElement.querySelectorAll('.selected');
        for (var i = 0; i < selected.length; i++) {
          selected.classList.remove('selected');
        }
      });
      
      itemTree.addEventListener('item-open', function onitemopen(e) {
        var itemEl = e.target;
        itemEl.classList.add('open');
        if (!itemEl.classList.contains('active')) {
          itemEl.classList.add('active', 'fetching');
          var id = +itemEl.id.match(/^item-(\d+)$/)[1];
          volumizer.getItemsIn(id).then(function(items) {
            for (var i = 0; i < items.length; i++) {
              var subitemEl = makeItemElement(items[i]);
              itemEl.childrenElement.appendChild(subitemEl);
              if (items.length === 1 && !itemEl.classList.contains('empty')) {
                subitemEl.dispatchEvent(new Event('item-open', {bubbles:true}));
              }
            }
            itemEl.classList.remove('fetching');
          });
        }
      });
      
      itemTree.addEventListener('item-set', function(e) {
        this.dataset.selectionMode = 'set';
        e.target.classList.toggle('selected');
      });
      
      Object.defineProperty(itemTree, 'focusItem', {
        get: function() {
          var referenceItem = document.activeElement;
          if (!referenceItem
              || !referenceItem.classList.contains('item-self')
              || !(referenceItem.compareDocumentPosition(this) & Node.DOCUMENT_POSITION_CONTAINS)) {
            return null;
          }
          while ((referenceItem = referenceItem.parentNode) !== this) {
            if (referenceItem.classList.contains('item')) return referenceItem;
          }
          return null;
        },
        set: function(item) {
          item.selfElement.focus();
        },
      });
      
      itemTree.nextItem = function(referenceItem) {
        if (referenceItem.classList.contains('open') && referenceItem.childrenElement.firstElementChild) {
          return referenceItem.childrenElement.firstElementChild;
        }
        do {
          if (referenceItem.nextElementSibling) {
            return referenceItem.nextElementSibling;
          }
          referenceItem = referenceItem.parentNode.parentNode;
        } while (referenceItem.classList.contains('item'));
        return null;
      },
      
      itemTree.previousItem = function(referenceItem) {
        if (referenceItem.previousElementSibling) {
          referenceItem = referenceItem.previousElementSibling;
          while (referenceItem.classList.contains('open') && referenceItem.childrenElement.firstElementChild) {
            referenceItem = referenceItem.childrenElement.lastElementChild;
          }
          return referenceItem;
        }
        referenceItem = referenceItem.parentNode.parentNode;
        if (referenceItem.classList.contains('item')) {
          return referenceItem;
        }
        return null;
      },
      
      itemTree.selectItemRange = function(fromItem, toItem) {
        var selected = this.querySelectorAll('.selected');
        for (var i = 0; i < selected.length; i++) {
          selected[i].classList.remove('selected');
        }
        if (fromItem.compareDocumentPosition(toItem) & Node.DOCUMENT_POSITION_PRECEDING) {
          this.dataset.selectionMode = 'range-reverse';
          for (var item = fromItem; item !== toItem; item = this.previousItem(item)) {
            item.classList.add('selected');
          }
          toItem.classList.add('selected');
        }
        else {
          this.dataset.selectionMode = 'range';
          for (var item = fromItem; item !== toItem; item = this.nextItem(item)) {
            item.classList.add('selected');
          }
          toItem.classList.add('selected');
        }
      };
      
      itemTree.addEventListener('item-range', function(e) {
        switch (this.dataset.selectionMode) {
          case 'set':
          default:
            this.selectItemRange(this.focusItem || e.target, e.target);
            break;
          case 'range':
            this.selectItemRange(this.querySelector('.selected') || e.target, e.target);
            break;
          case 'range-reverse':
            var allSelected = this.querySelectorAll('.selected');
            this.selectItemRange(allSelected[allSelected.length-1] || e.target, e.target);
            break;
        }
      });
      
      itemTree.addEventListener('keydown', function onkeydown(e) {
        e.preventDefault();
        switch (e.keyCode) {
          case 32: // space
            var selected = this.querySelectorAll('.selected');
            if (selected.length !== 0) {
              var whichEvent = selected[0].classList.contains('open') ? 'item-close' : 'item-open';
              for (var i = 0; i < selected.length; i++) {
                selected[0].dispatchEvent(new Event(whichEvent, {bubbles:true}));
              }
            }
            break;
          case 33: // page up
            var refItem = this.focusItem;
            if (!refItem) return;
            var prevRef = this.previousItem(refItem);
            if (prevRef) {
              refItem = prevRef;
              var rect = refItem.selfElement.getBoundingClientRect();
              var minTop = 0;
              if (rect.top < minTop) {
                minTop = rect.bottom - this.clientHeight;
              }
              for (prevRef = this.previousItem(refItem); prevRef; prevRef = this.previousItem(prevRef)) {
                if (prevRef.selfElement.getBoundingClientRect().top < minTop) break;
                refItem = prevRef;
              }
            }
            if (e.shiftKey) {
              refItem.dispatchEvent(new Event('item-range', {bubbles:true}));
            }
            else if (!e.ctrlKey) {
              this.selectItemRange(refItem, refItem);
            }
            refItem.scrollIntoView(true);
            this.focusItem = refItem;
            break;
          case 34: // page down
            var refItem = this.focusItem;
            if (!refItem) return;
            var nextRef = this.nextItem(refItem);
            if (nextRef) {
              refItem = nextRef;
              var rect = refItem.selfElement.getBoundingClientRect();
              var maxBottom = this.clientHeight;
              if (rect.bottom > maxBottom) {
                maxBottom = rect.top + this.clientHeight;
              }
              for (nextRef = this.nextItem(refItem); nextRef; nextRef = this.nextItem(nextRef)) {
                if (nextRef.selfElement.getBoundingClientRect().bottom > maxBottom) break;
                refItem = nextRef;
              }
            }
            if (e.shiftKey) {
              refItem.dispatchEvent(new Event('item-range', {bubbles:true}));
            }
            else if (!e.ctrlKey) {
              this.selectItemRange(refItem, refItem);
            }
            refItem.scrollIntoView(false);
            this.focusItem = refItem;
            break;
          case 37: // left
            var selected = this.querySelectorAll('.selected');
            if (selected.length === 1 && !selected[0].classList.contains('open')) {
              // move to parent instead
              var above = selected[0].parentNode.parentNode;
              if (above.classList.contains('item')) {
                this.selectItemRange(above, above);
                this.focusItem = above;
              }
            }
            else for (var i = 0; i < selected.length; i++) {
              selected[i].dispatchEvent(new Event('item-close', {bubbles:true}));
            }
            break;
          case 38: // up
            var prev = this.previousItem(this.focusItem) || this.focusItem;
            if (!prev) return;
            if (e.shiftKey) {
              prev.dispatchEvent(new Event('item-range', {bubbles:true}));
            }
            else if (!e.ctrlKey) {
              this.selectItemRange(prev, prev);
            }
            prev.scrollIntoView(true);
            this.focusItem = prev;
            break;
          case 39: // right
            var selected = this.querySelectorAll('.selected');
            if (selected.length === 1 && selected[0].classList.contains('open')) {
              // go to first child instead
              if (selected[0].childrenElement.firstElementChild) {
                selected[0].classList.remove('selected');
                selected[0].childrenElement.firstElementChild.classList.add('selected');
                this.focusItem = selected[0].childrenElement.firstElementChild;
              }
            }
            else for (var i = 0; i < selected.length; i++) {
              selected[i].dispatchEvent(new Event('item-open', {bubbles:true}));
            }
            break;
          case 40: // down
            var next = this.nextItem(this.focusItem) || this.focusItem;
            if (!next) return;
            if (e.shiftKey) {
              next.dispatchEvent(new Event('item-range', {bubbles:true}));
            }
            else if (!e.ctrlKey) {
              this.selectItemRange(next, next);
            }
            next.scrollIntoView(false);
            this.focusItem = next;
            break;
        }
      });
      
      self.addEventListener('volumizer-section-update', function(e) {
        volumizer.getItems(e.detail.sections).then(function(items) {
          if (items.length !== e.detail.sections) {
            var present = {};
            for (var i = 0; i < items.length; i++) {
              present[items[i].id] = true;
            }
            for (var i = 0; i < e.detail.sections.length; i++) {
              if (e.detail.sections[i] in present) continue;
              var itemEl = document.getElementById('item-' + e.detail.sections[i]);
              if (itemEl) {
                if (itemEl.parentNode.childElementCount === 1) {
                  itemEl.parentNode.parentNode.classList.add('empty');
                }
                itemEl.parentNode.removeChild(itemEl);
              }
            }
          }
          for (var i = 0; i < items.length; i++) {
            var itemEl = document.getElementById('item-' + items[i].id);
            if (itemEl) updateItemElement(itemEl, item);
            else if (items[i].parent < 0) {
              itemTree.appendChild(makeItemElement(items[i]));
            }
            else {
              var parentEl = document.getElementById('item-' + items[i].parent);
              if (parentEl) {
                parentEl.classList.remove('empty');
                if (parentEl.classList.contains('active')) {
                  parentEl.childrenElement.appendChild(makeItemElement(items[i]));
                }
              }
            }
          }
        });
      });
      
      volumizer.getItemsIn(-1).then(function(items) {
        for (var i = 0; i < items.length; i++) {
          itemTree.appendChild(makeItemElement(items[i]));
        }
      });
      
      var loadBar = document.getElementById('loadbar');
      loadBar.toDo = 0;
      loadBar.completed = 0;
      window.addEventListener('task-counter', function(e) {
        if (e.detail < 0) {
          loadBar.completed -= e.detail;
        }
        else if (e.detail > 0) {
          if (loadBar.toDo === 0) {
            loadBar.style.opacity = '';
          }
          loadBar.toDo += e.detail;
        }
        else return;
        loadBar.style.transform = 'scaleX(' + (loadBar.completed / loadBar.toDo) + ')';
        if (loadBar.completed === loadBar.toDo) {
          loadBar.completed = loadBar.toDo = 0;
          loadBar.style.opacity = 0;
        }
      });
      
    </script>
  </body>
</html>
